name: Build driver
on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: rubikpi3
            script: ./install_rubikpi3.sh
            base_image: "https://people.canonical.com/~platform/images/qualcomm-iot/rubikpi3/ubuntu-server-24.04/x00/ubuntu-24.04-preinstalled-server-arm64+rubikpi3-20250912-127.yaml"
                        
    name: "Build for ${{ matrix.name }}"

    steps:
    - uses: actions/checkout@v4.1.7
      with:
        fetch-depth: 0
    - name: Fetch tags
      run: git fetch --tags --force

    - name: Build rubikpi3 with custom mounting
      if: matrix.name == 'rubikpi3'
      run: |
        set -ex
        
        # Install required packages
        sudo apt-get update
        sudo apt-get install -y qemu-user-static wget xz-utils rsync yq gdisk parted
        
        # Download and process manifest
        wget -O manifest.yaml "${{ matrix.base_image }}"
        
        echo "=== Manifest contents ==="
        cat manifest.yaml
        echo "========================="
        
        # Process each component using awk to extract URL and SHA256
        awk '/url:/ {
                sub(/.*url:[[:space:]]*/,"",$0);
                url=$0
             }
             /sha256sum:/ {
                sub(/.*sha256sum:[[:space:]]*/,"",$0);
                print url, $0
             }' manifest.yaml | while read -r url sha; do
          filename=$(basename "$url")
          echo "Downloading: $filename from $url"
          wget -O "$filename" "$url"
          echo "$sha  $filename" | sha256sum -c -
        done
        
        echo "=== Downloaded files ==="
        ls -lh
        echo "========================"
        
        # Find the rootfs image - look for the largest .img.xz file or one with "rootfs" in name
        ROOTFS_IMG_XZ=""
        
        # First try to find a file with "rootfs" in the name
        for file in *.img.xz; do
          if [[ "$file" == *"rootfs"* ]]; then
            ROOTFS_IMG_XZ="$file"
            echo "Found rootfs image by name: $ROOTFS_IMG_XZ"
            break
          fi
        done
        
        # If not found, use the largest .img.xz file
        if [ -z "$ROOTFS_IMG_XZ" ]; then
          ROOTFS_IMG_XZ=$(ls -S *.img.xz 2>/dev/null | head -n1)
          echo "Using largest .img.xz file as rootfs: $ROOTFS_IMG_XZ"
        fi
        
        if [ -z "$ROOTFS_IMG_XZ" ] || [ ! -f "$ROOTFS_IMG_XZ" ]; then
          echo "Error: Could not find a suitable rootfs image file"
          echo "Available files:"
          ls -la
          exit 1
        fi
        
        ROOTFS_IMG="${ROOTFS_IMG_XZ%.xz}"
        
        echo "Extracting rootfs image: $ROOTFS_IMG_XZ"
        xz -d "$ROOTFS_IMG_XZ"
        
        if [ ! -f "$ROOTFS_IMG" ]; then
          echo "Error: Failed to extract $ROOTFS_IMG"
          exit 1
        fi
        
        echo "Using rootfs image: $ROOTFS_IMG"
        
        # Check if this is a raw filesystem or a partitioned disk image
        echo "=== Analyzing image structure ==="
        sudo fdisk -l "$ROOTFS_IMG" || true
        
        # First, try to fix any GPT issues before analyzing
        echo "Attempting to fix GPT if present..."
        echo -e "r\ne\nw\ny" | sudo gdisk "$ROOTFS_IMG" || true
        
        # Now check the partition table again
        echo "=== Re-analyzing after GPT fix ==="
        sudo fdisk -l "$ROOTFS_IMG"
        sudo parted "$ROOTFS_IMG" unit s print || true
        
        # Use losetup to create a loop device for proper partition detection
        echo "Creating loop device..."
        LOOP_DEV=$(sudo losetup -f --show -P "$ROOTFS_IMG")
        echo "Loop device created: $LOOP_DEV"
        
        # Wait a moment for partition devices to appear
        sleep 2
        
        # List partition devices
        echo "Partition devices:"
        ls -la ${LOOP_DEV}* || true
        
        # Check if there are partition devices
        PARTITION_DEVS=$(ls ${LOOP_DEV}p* 2>/dev/null | wc -l)
        echo "Found $PARTITION_DEVS partition device(s)"
        
        if [ "$PARTITION_DEVS" -eq 0 ]; then
          echo "=== No partition devices found - trying direct mount ==="
          
          # Try to mount the loop device directly
          mkdir -p ./rootfs
          if sudo mount "$LOOP_DEV" ./rootfs 2>/dev/null; then
            echo "Successfully mounted loop device as raw filesystem"
            
            # Unmount to expand
            sudo umount ./rootfs
            sudo losetup -d "$LOOP_DEV"
            
            # Expand the image
            echo "Expanding raw filesystem image by 3800MB..."
            dd if=/dev/zero bs=1M count=3800 >> "$ROOTFS_IMG"
            
            # Resize the filesystem
            echo "Resizing ext4 filesystem..."
            sudo e2fsck -f -y "$ROOTFS_IMG" || true
            sudo resize2fs "$ROOTFS_IMG"
            
            # Remount
            LOOP_DEV=$(sudo losetup -f --show "$ROOTFS_IMG")
            sudo mount "$LOOP_DEV" ./rootfs
            MOUNTED=true
          else
            echo "Error: Cannot mount as raw filesystem"
            sudo losetup -d "$LOOP_DEV"
            file "$ROOTFS_IMG"
            sudo blkid "$ROOTFS_IMG" || true
            exit 1
          fi
        else
          echo "=== Found partition devices - treating as partitioned disk ==="
          
          # Get the last partition device (usually the rootfs)
          ROOTFS_PART=$(ls ${LOOP_DEV}p* 2>/dev/null | tail -n1)
          echo "Using partition: $ROOTFS_PART"
          
          # Unmount loop device to expand the image
          sudo losetup -d "$LOOP_DEV"
          
          # Expand the image
          echo "Expanding disk image by 3800MB..."
          dd if=/dev/zero bs=1M count=3800 >> "$ROOTFS_IMG"
          
          # Fix GPT after expansion
          echo "Fixing GPT after expansion..."
          echo -e "r\ne\nw\ny" | sudo gdisk "$ROOTFS_IMG" || true
          
          # Recreate loop device
          LOOP_DEV=$(sudo losetup -f --show -P "$ROOTFS_IMG")
          sleep 2
          
          # Get the partition device again
          ROOTFS_PART=$(ls ${LOOP_DEV}p* 2>/dev/null | tail -n1)
          echo "Partition after expansion: $ROOTFS_PART"
          
          # Mount the partition
          mkdir -p ./rootfs
          sudo mount "$ROOTFS_PART" ./rootfs
          
          # Resize the filesystem
          echo "Resizing filesystem..."
          sudo resize2fs "$ROOTFS_PART" || echo "Warning: resize2fs failed"
          MOUNTED=true
        fi
        
        # Setup chroot environment
        sudo mount -t proc proc rootfs/proc
        sudo mount -t sysfs sysfs rootfs/sys
        sudo mount -t tmpfs tmpfs rootfs/run
        sudo mount --bind /dev rootfs/dev
        
        # Copy qemu static binaries for ARM emulation
        sudo cp /usr/bin/qemu-arm-static rootfs/usr/bin/ || true
        sudo cp /usr/bin/qemu-aarch64-static rootfs/usr/bin/ || true
        
        # Copy repository into chroot (excluding mounted directories and problematic files)
        sudo mkdir -p rootfs/tmp/build/
        sudo rsync -av --exclude=rootfs --exclude=.git --exclude=*.img --exclude=*.xz . rootfs/tmp/build/
        
        # Run the installation scripts in chroot
        sudo chroot rootfs /bin/bash -c "
          cd /tmp/build
          chmod +x ${{ matrix.script }}
          ./${{ matrix.script }}
          chmod +x ./install_common.sh
          ./install_common.sh
          mkdir -p /opt/photonvision/
          echo '${{ github.ref_name }};${{ matrix.name }}' > /opt/photonvision/image-version
        "
        
        # Cleanup mounts
        sudo umount rootfs/dev || true
        sudo umount rootfs/run || true
        sudo umount rootfs/sys || true
        sudo umount rootfs/proc || true
        sudo umount rootfs || true
        
        # Cleanup loop device if it exists
        if [ -n "$LOOP_DEV" ]; then
          sudo losetup -d "$LOOP_DEV" || true
        fi
        
        # Assembly process for remaining files
        mkdir -p QLI
        # Extract .tar.gz archive(s) directly into QLI
        if ls *.tar.gz 1>/dev/null 2>&1; then
          tar -xzf *.tar.gz -C QLI
        fi
        # Move all files (rawprogram, dtb, img) into QLI
        mv rawprogram*.xml QLI/ 2>/dev/null || true
        mv dtb.bin QLI/ 2>/dev/null || true
        mv *.img QLI/ 2>/dev/null || true
        
        # Flatten directory structure - move all files from subdirectories to QLI root
        find QLI -mindepth 2 -type f -exec mv {} QLI/ \;
        # Remove empty subdirectories
        find QLI -mindepth 1 -type d -empty -delete
        
        # Set output for later steps
        echo "image=$ROOTFS_IMG" >> $GITHUB_OUTPUT
      id: install_deps_rubikpi3

    # Image compression step removed as only the QLI directory is needed

    - name: Archive full QLI directory
      run: |
        tar -cf photonvision_${{ matrix.name }}_full.tar.gz -C QLI .
    - uses: actions/upload-artifact@v4.3.4
      with:
        name: photonvision_${{ matrix.name }}_full
        path: photonvision_${{ matrix.name }}_full.tar.gz
        if-no-files-found: error
        retention-days: 1

  release:
    needs: [build]
    runs-on: ubuntu-22.04
    steps:
      # Download literally every single artifact
      - uses: actions/download-artifact@v4.1.8
      - run: find
      # Push to dev release
      - uses: pyTooling/Actions/releaser@v1.0.5
        if: github.event_name == 'push'
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: 'Dev'
          rm: true
          files: |
            **/*.tar.gz
      # Upload all tar.gz archives to GH tag if tagged
      - uses: softprops/action-gh-release@v2.0.8
        if: startsWith(github.ref, 'refs/tags/v')
        with:
          files: |
            **/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
