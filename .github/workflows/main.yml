name: Build driver
on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - name: rubikpi3
            script: ./install_rubikpi3.sh
            base_image: "https://people.canonical.com/~platform/images/qualcomm-iot/rubikpi3/ubuntu-server-24.04/x00/ubuntu-24.04-preinstalled-server-arm64+rubikpi3-20250912-127.yaml"
                        
    name: "Build for ${{ matrix.name }}"

    steps:
    - uses: actions/checkout@v4.1.7
      with:
        fetch-depth: 0
    - name: Fetch tags
      run: git fetch --tags --force

    - name: Build rubikpi3 with custom mounting
      if: matrix.name == 'rubikpi3'
      run: |
        set -ex
        
        # Install required packages
        sudo apt-get update
        sudo apt-get install -y qemu-user-static wget xz-utils rsync yq gdisk parted
        
        # Download and process manifest
        wget -O manifest.yaml "${{ matrix.base_image }}"
        
        echo "=== Manifest contents ==="
        cat manifest.yaml
        echo "========================="
        
        # Process each component using awk to extract URL and SHA256
        awk '/url:/ {
                sub(/.*url:[[:space:]]*/,"",$0);
                url=$0
             }
             /sha256sum:/ {
                sub(/.*sha256sum:[[:space:]]*/,"",$0);
                print url, $0
             }' manifest.yaml | while read -r url sha; do
          filename=$(basename "$url")
          echo "Downloading: $filename from $url"
          wget -O "$filename" "$url"
          echo "$sha  $filename" | sha256sum -c -
        done
        
        echo "=== Downloaded files ==="
        ls -lh
        echo "========================"
        
        # Find the rootfs image - look for the largest .img.xz file or one with "rootfs" in name
        ROOTFS_IMG_XZ=""
        
        # First try to find a file with "rootfs" in the name
        for file in *.img.xz; do
          if [[ "$file" == *"rootfs"* ]]; then
            ROOTFS_IMG_XZ="$file"
            echo "Found rootfs image by name: $ROOTFS_IMG_XZ"
            break
          fi
        done
        
        # If not found, use the largest .img.xz file
        if [ -z "$ROOTFS_IMG_XZ" ]; then
          ROOTFS_IMG_XZ=$(ls -S *.img.xz 2>/dev/null | head -n1)
          echo "Using largest .img.xz file as rootfs: $ROOTFS_IMG_XZ"
        fi
        
        if [ -z "$ROOTFS_IMG_XZ" ] || [ ! -f "$ROOTFS_IMG_XZ" ]; then
          echo "Error: Could not find a suitable rootfs image file"
          echo "Available files:"
          ls -la
          exit 1
        fi
        
        ROOTFS_IMG="${ROOTFS_IMG_XZ%.xz}"
        
        echo "Extracting rootfs image: $ROOTFS_IMG_XZ"
        xz -d "$ROOTFS_IMG_XZ"
        
        if [ ! -f "$ROOTFS_IMG" ]; then
          echo "Error: Failed to extract $ROOTFS_IMG"
          exit 1
        fi
        
        echo "Using rootfs image: $ROOTFS_IMG"
        
        # Check if this is a raw filesystem or a partitioned disk image
        echo "=== Analyzing image structure ==="
        sudo fdisk -l "$ROOTFS_IMG" || true
        file "$ROOTFS_IMG"
        sudo blkid "$ROOTFS_IMG" || true
        
        # Fix PMBR size mismatch if present
        echo "=== Fixing PMBR size mismatch ==="
        echo "w" | sudo fdisk "$ROOTFS_IMG" || true
        
        echo "=== After PMBR fix ==="
        sudo fdisk -l "$ROOTFS_IMG"
        
        # Rebuild GPT from protective MBR
        echo "=== Rebuilding GPT from protective MBR ==="
        echo -e "r\nb\nw\ny" | sudo gdisk "$ROOTFS_IMG" || true
        
        echo "=== After GPT rebuild ==="
        sudo fdisk -l "$ROOTFS_IMG"
        sudo parted "$ROOTFS_IMG" print || true
        
        # Use losetup to create a loop device for proper partition detection
        echo "=== Creating loop device ==="
        LOOP_DEV=$(sudo losetup -f --show -P "$ROOTFS_IMG")
        echo "Loop device created: $LOOP_DEV"
        
        # Force kernel to re-read partition table
        sudo partprobe "$LOOP_DEV" 2>/dev/null || true
        sleep 2
        
        # List partition devices
        echo "=== Partition devices ==="
        ls -la ${LOOP_DEV}* || true
        
        # Check if there are partition devices
        PARTITION_DEVS=$(ls ${LOOP_DEV}p* 2>/dev/null | wc -l)
        echo "Found $PARTITION_DEVS partition device(s)"
        
        mkdir -p ./rootfs
        
        if [ "$PARTITION_DEVS" -gt 0 ]; then
          echo "=== Mounting partition device ==="
          ROOTFS_PART=$(ls ${LOOP_DEV}p* 2>/dev/null | tail -n1)
          echo "Using partition: $ROOTFS_PART"
          
          if sudo mount "$ROOTFS_PART" ./rootfs; then
            echo "Successfully mounted partition"
            MOUNT_TYPE="partition"
          else
            echo "Failed to mount partition, trying offset method"
            MOUNT_TYPE="none"
          fi
        else
          echo "=== No partition devices, trying direct loop mount ==="
          if sudo mount "$LOOP_DEV" ./rootfs 2>/dev/null; then
            echo "Successfully mounted loop device directly"
            MOUNT_TYPE="loop"
          else
            echo "Failed to mount loop device, trying offset method"
            MOUNT_TYPE="none"
          fi
        fi
        
        # Fallback: try mounting with offset from MBR
        if [ "$MOUNT_TYPE" = "none" ]; then
          echo "=== Trying offset mount from MBR partition entry ==="
          sudo losetup -d "$LOOP_DEV"
          
          START_SECTOR=$(sudo fdisk -l "$ROOTFS_IMG" | grep "^${ROOTFS_IMG}1" | awk '{print $2}')
          if [ -n "$START_SECTOR" ]; then
            OFFSET=$((START_SECTOR * 512))
            echo "Start sector: $START_SECTOR, Offset: $OFFSET bytes"
            
            if sudo mount -o loop,offset=$OFFSET "$ROOTFS_IMG" ./rootfs; then
              echo "Successfully mounted with offset"
              MOUNT_TYPE="offset"
              # Create a new loop device for the offset mount
              LOOP_DEV=$(sudo losetup -j "$ROOTFS_IMG" | cut -d: -f1)
            else
              echo "Error: All mount attempts failed"
              exit 1
            fi
          else
            echo "Error: Could not determine partition offset"
            exit 1
          fi
        fi
        
        echo "=== Mount successful, type: $MOUNT_TYPE ==="
        ls -la ./rootfs | head -20
        
        # Now expand the image
        echo "=== Unmounting for expansion ==="
        sudo umount ./rootfs
        if [ -n "$LOOP_DEV" ]; then
          sudo losetup -d "$LOOP_DEV" 2>/dev/null || true
        fi
        
        # Expand the image
        echo "=== Expanding image by 3800MB ==="
        dd if=/dev/zero bs=1M count=3800 >> "$ROOTFS_IMG"
        
        # Fix partition table after expansion
        if [ "$MOUNT_TYPE" = "partition" ] || [ "$MOUNT_TYPE" = "offset" ]; then
          echo "=== Fixing partition table after expansion ==="
          echo "w" | sudo fdisk "$ROOTFS_IMG" || true
          echo -e "r\nb\nw\ny" | sudo gdisk "$ROOTFS_IMG" || true
        fi
        
        # Remount based on original mount type
        echo "=== Remounting after expansion ==="
        if [ "$MOUNT_TYPE" = "partition" ]; then
          LOOP_DEV=$(sudo losetup -f --show -P "$ROOTFS_IMG")
          sudo partprobe "$LOOP_DEV" 2>/dev/null || true
          sleep 2
          ROOTFS_PART=$(ls ${LOOP_DEV}p* 2>/dev/null | tail -n1)
          sudo mount "$ROOTFS_PART" ./rootfs
          echo "Resizing filesystem on partition..."
          sudo resize2fs "$ROOTFS_PART" || echo "Warning: resize2fs failed"
        elif [ "$MOUNT_TYPE" = "loop" ]; then
          LOOP_DEV=$(sudo losetup -f --show "$ROOTFS_IMG")
          sudo mount "$LOOP_DEV" ./rootfs
          echo "Resizing filesystem..."
          sudo e2fsck -f -y "$ROOTFS_IMG" || true
          sudo resize2fs "$ROOTFS_IMG"
        elif [ "$MOUNT_TYPE" = "offset" ]; then
          START_SECTOR=$(sudo fdisk -l "$ROOTFS_IMG" | grep "^${ROOTFS_IMG}1" | awk '{print $2}')
          OFFSET=$((START_SECTOR * 512))
          sudo mount -o loop,offset=$OFFSET "$ROOTFS_IMG" ./rootfs
          LOOP_DEV=$(sudo losetup -j "$ROOTFS_IMG" | cut -d: -f1)
          echo "Resizing filesystem with offset..."
          sudo resize2fs "$LOOP_DEV" || echo "Warning: resize2fs failed"
        fi
        
        echo "=== Filesystem ready ==="
        
        # Setup chroot environment
        sudo mount -t proc proc rootfs/proc
        sudo mount -t sysfs sysfs rootfs/sys
        sudo mount -t tmpfs tmpfs rootfs/run
        sudo mount --bind /dev rootfs/dev
        
        # Copy qemu static binaries for ARM emulation
        sudo cp /usr/bin/qemu-arm-static rootfs/usr/bin/ || true
        sudo cp /usr/bin/qemu-aarch64-static rootfs/usr/bin/ || true
        
        # Copy repository into chroot (excluding mounted directories and problematic files)
        sudo mkdir -p rootfs/tmp/build/
        sudo rsync -av --exclude=rootfs --exclude=.git --exclude=*.img --exclude=*.xz . rootfs/tmp/build/
        
        # Run the installation scripts in chroot
        sudo chroot rootfs /bin/bash -c "
          cd /tmp/build
          chmod +x ${{ matrix.script }}
          ./${{ matrix.script }}
          chmod +x ./install_common.sh
          ./install_common.sh
          mkdir -p /opt/photonvision/
          echo '${{ github.ref_name }};${{ matrix.name }}' > /opt/photonvision/image-version
        "
        
        # Cleanup mounts
        sudo umount rootfs/dev || true
        sudo umount rootfs/run || true
        sudo umount rootfs/sys || true
        sudo umount rootfs/proc || true
        sudo umount rootfs || true
        
        # Cleanup loop device if it exists
        if [ -n "$LOOP_DEV" ]; then
          sudo losetup -d "$LOOP_DEV" || true
        fi
        
        # Assembly process for remaining files
        mkdir -p QLI
        # Extract .tar.gz archive(s) directly into QLI
        if ls *.tar.gz 1>/dev/null 2>&1; then
          tar -xzf *.tar.gz -C QLI
        fi
        # Move all files (rawprogram, dtb, img) into QLI
        mv rawprogram*.xml QLI/ 2>/dev/null || true
        mv dtb.bin QLI/ 2>/dev/null || true
        mv *.img QLI/ 2>/dev/null || true
        
        # Flatten directory structure - move all files from subdirectories to QLI root
        find QLI -mindepth 2 -type f -exec mv {} QLI/ \;
        # Remove empty subdirectories
        find QLI -mindepth 1 -type d -empty -delete
        
        # Set output for later steps
        echo "image=$ROOTFS_IMG" >> $GITHUB_OUTPUT
      id: install_deps_rubikpi3

    # Image compression step removed as only the QLI directory is needed

    - name: Archive full QLI directory
      run: |
        tar -cf photonvision_${{ matrix.name }}_full.tar.gz -C QLI .
    - uses: actions/upload-artifact@v4.3.4
      with:
        name: photonvision_${{ matrix.name }}_full
        path: photonvision_${{ matrix.name }}_full.tar.gz
        if-no-files-found: error
        retention-days: 1

  release:
    needs: [build]
    runs-on: ubuntu-22.04
    steps:
      # Download literally every single artifact
      - uses: actions/download-artifact@v4.1.8
      - run: find
      # Push to dev release
      - uses: pyTooling/Actions/releaser@v1.0.5
        if: github.event_name == 'push'
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: 'Dev'
          rm: true
          files: |
            **/*.tar.gz
      # Upload all tar.gz archives to GH tag if tagged
      - uses: softprops/action-gh-release@v2.0.8
        if: startsWith(github.ref, 'refs/tags/v')
        with:
          files: |
            **/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
