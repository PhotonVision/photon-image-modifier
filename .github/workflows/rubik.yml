name: Build driver
on:
  push:
    branches: [ main, rubik-pi-image ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      script: "./install_rubikpi3.sh"
      base_image: "https://people.canonical.com/~platform/images/qualcomm-iot/rubikpi3/ubuntu-server-24.04/x00/ubuntu-24.04-preinstalled-server-arm64+rubikpi3-20250912-127.yaml"  
                        
    name: "Build for RubikPi3"

    steps:
    - uses: actions/checkout@v4.1.7
      with:
        fetch-depth: 0
    - name: Fetch tags
      run: git fetch --tags --force

    - name: Build rubikpi3 with mounting
      run: |
        set -exv
        
        # Install required packages
        sudo apt-get update
        sudo apt-get install -y qemu-user-static wget xz-utils rsync
        
        # Download and process manifest
        wget -O manifest.yaml "${{ base_image }}"
        
        echo "=== Manifest contents ==="
        cat manifest.yaml
        echo "========================="
        
        # Process each component using awk to extract URL and SHA256
        awk '/url:/ {
                sub(/.*url:[[:space:]]*/,"",$0);
                url=$0
             }
             /sha256sum:/ {
                sub(/.*sha256sum:[[:space:]]*/,"",$0);
                print url, $0
             }' manifest.yaml | while read -r url sha; do
          filename=$(basename "$url")
          echo "Downloading: $filename from $url"
          wget -O "$filename" "$url"
          echo "$sha  $filename" | sha256sum -c -
        done
        
        echo "=== Downloaded files ==="
        ls -lh
        echo "========================"
        
        # Find the rootfs image - look for the largest .img.xz file or one with "rootfs" in name
        ROOTFS_IMG_XZ=""
        
        # First try to find a file with "rootfs" in the name
        for file in *.img.xz; do
          if [[ "$file" == *"rootfs"* ]]; then
            ROOTFS_IMG_XZ="$file"
            echo "Found rootfs image by name: $ROOTFS_IMG_XZ"
            break
          fi
        done
        
        # If not found, use the largest .img.xz file
        if [ -z "$ROOTFS_IMG_XZ" ]; then
          ROOTFS_IMG_XZ=$(ls -S *.img.xz 2>/dev/null | head -n1)
          echo "Using largest .img.xz file as rootfs: $ROOTFS_IMG_XZ"
        fi
        
        if [ -z "$ROOTFS_IMG_XZ" ] || [ ! -f "$ROOTFS_IMG_XZ" ]; then
          echo "Error: Could not find a suitable rootfs image file"
          echo "Available files:"
          ls -la
          exit 1
        fi
        
        ROOTFS_IMG="${ROOTFS_IMG_XZ%.xz}"
        
        echo "Extracting rootfs image: $ROOTFS_IMG_XZ"
        xz -d "$ROOTFS_IMG_XZ"
        
        if [ ! -f "$ROOTFS_IMG" ]; then
          echo "Error: Failed to extract $ROOTFS_IMG"
          exit 1
        fi
        
        echo "Using rootfs image: $ROOTFS_IMG"
        
        # This uses a fixed offset for Ubuntu preinstalled server images
        echo "=== Mounting rootfs with fixed offset (rpiimager method) ==="
        mkdir -p ./rootfs
        
        # Calculate offset: 4096 bytes/sector * 139008 sectors = 569,376,768 bytes
        OFFSET=$((4096*139008))
        echo "Using offset: $OFFSET bytes (sector 139008)"
        
        sudo mount -o rw,loop,offset=$OFFSET "$ROOTFS_IMG" ./rootfs
        
        if [ $? -ne 0 ]; then
          echo "Error: Failed to mount image with fixed offset"
          exit 1
        fi
        
        echo "=== Mount successful ==="
        ls -la ./rootfs | head -20
        
        # Check if this is a Canonical or Modified image (from rpiimager logic)
        if [ -f "rootfs/etc/ImgType" ]; then
          cp rootfs/etc/ImgType ImgType
        else
          echo "Canonical" > ImgType
        fi
        read ImgType < ImgType
        echo "Image type: $ImgType"
        
        # Expand image if it's a Canonical image (first time modification)
        if [ "$ImgType" == "Canonical" ]; then
          echo "=== Marking image as CustomIDE ==="
          sudo chroot rootfs /bin/bash -c "
            touch /etc/ImgType
            echo 'CustomIDE' > /etc/ImgType
          "
          
          echo "=== Unmounting for expansion ==="
          sudo umount ./rootfs
          
          # Expand the image by 4GB (reduced from 10GB to fit GitHub Actions disk space)
          echo "=== Expanding image by 4GB ==="
          dd if=/dev/zero bs=1M count=4096 >> "$ROOTFS_IMG"
          
          # Remount after expansion
          echo "=== Remounting after expansion ==="
          sudo mount -o rw,loop,offset=$OFFSET "$ROOTFS_IMG" ./rootfs
        elif [ "$ImgType" == "CustomIDE" ]; then
          echo "Image already customized, no expansion needed"
        fi
        
        rm -f ImgType
        
        echo "=== Filesystem ready ==="
        
        # Setup chroot environment
        sudo mount -t proc proc rootfs/proc
        sudo mount -t sysfs sysfs rootfs/sys
        sudo mount -t tmpfs tmpfs rootfs/run
        sudo mount --bind /dev rootfs/dev
        
        # Setup DNS resolution in chroot
        echo "=== Setting up DNS in chroot ==="
        sudo rm -f rootfs/etc/resolv.conf
        sudo cp /etc/resolv.conf rootfs/etc/resolv.conf
        sudo cp /etc/hosts rootfs/etc/hosts
        
        # Copy qemu static binaries for ARM emulation
        sudo cp /usr/bin/qemu-arm-static rootfs/usr/bin/ || true
        sudo cp /usr/bin/qemu-aarch64-static rootfs/usr/bin/ || true
        
        # Copy repository into chroot (excluding mounted directories and problematic files)
        sudo mkdir -p rootfs/tmp/build/
        sudo rsync -av --exclude=rootfs --exclude=.git --exclude=*.img --exclude=*.xz . rootfs/tmp/build/
        
        # Install sudo in the chroot environment (needed by install scripts)
        echo "=== Installing sudo in chroot ==="
        sudo chroot rootfs /usr/bin/qemu-aarch64-static /bin/bash -c "set -exv && DEBIAN_FRONTEND=noninteractive apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y sudo"
        
        # Run the installation scripts in chroot with verbose output
        echo "=== Running installation scripts in chroot ==="
        sudo chroot rootfs /usr/bin/qemu-aarch64-static /bin/bash -c "
          set -exv
          export DEBIAN_FRONTEND=noninteractive
          cd /tmp/build
          echo '=== Current directory: \$(pwd) ==='
          echo '=== Files in current directory: ==='
          ls -la
          echo '=== Making script executable ==='
          chmod +x ${{ script }}
          echo '=== Running ${{ script }} ==='
          ./${{ script }}
          echo '=== Running install_common.sh ==='
          chmod +x ./install_common.sh
          ./install_common.sh
          echo '=== Creating version file ==='
          mkdir -p /opt/photonvision/
          echo '${{ github.ref_name }};${{ name }}' > /opt/photonvision/image-version
          echo '=== Installation complete ==='
        "
        
        # Cleanup mounts
        sudo umount rootfs/dev || true
        sudo umount rootfs/run || true
        sudo umount rootfs/sys || true
        sudo umount rootfs/proc || true
        sudo umount rootfs || true
        
        # Cleanup loop device if it exists
        if [ -n "$LOOP_DEV" ]; then
          sudo losetup -d "$LOOP_DEV" || true
        fi
        
        # Assembly process for remaining files
        mkdir -p QLI
        # Extract .tar.gz archive(s) directly into QLI
        if ls *.tar.gz 1>/dev/null 2>&1; then
          tar -xzf *.tar.gz -C QLI
        fi
        # Move all files (rawprogram, dtb, img) into QLI
        mv rawprogram*.xml QLI/ 2>/dev/null || true
        mv dtb.bin QLI/ 2>/dev/null || true
        mv *.img QLI/ 2>/dev/null || true
        
        # Flatten directory structure - move all files from subdirectories to QLI root
        find QLI -mindepth 2 -type f -exec mv {} QLI/ \;
        # Remove empty subdirectories
        find QLI -mindepth 1 -type d -empty -delete
        
        # Set output for later steps
        echo "image=$ROOTFS_IMG" >> $GITHUB_OUTPUT
        tar -cf photonvision_rubikpi3_full.tar.gz -C QLI .
      id: install_deps_rubikpi3

    - uses: actions/upload-artifact@v4.3.4
      with:
        path: photonvision_rubikpi3_full.tar.gz
        if-no-files-found: error
        retention-days: 1

  release:
    needs: [build]
    runs-on: ubuntu-22.04
    steps:
      # Download literally every single artifact
      - uses: actions/download-artifact@v4.1.8
      - run: find
      # Push to dev release
      - uses: pyTooling/Actions/releaser@v1.0.5
        if: github.event_name == 'push'
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag: 'Dev'
          rm: true
          files: |
            **/*.zip
      # Upload all tar.gz archives to GH tag if tagged
      - uses: softprops/action-gh-release@v2.0.8
        if: startsWith(github.ref, 'refs/tags/v')
        with:
          files: |
            **/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
